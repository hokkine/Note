2025/2/14 小红书golang对象存储

redis集群，redis底层模型，为什么单线程，redis集群保证数据一致性

延申至 -> 分布式理论，CAP、BASE、Raft算法



2025/2/14 腾讯2面

- 实习经历，需求如何落地，如何对接，自己是如何实现的

- 身份验证如何实现 token jwt 细节 (忘记了)

- 为什么找下一段实习，未来的规划，会选择哪种方向，偏向哪些业务





2025/2/24  cider 1面 

- 

2025/2/24  法大大 1面

- 

2025/2/25  货拉拉1面

- 

2025/2/25  得物(云原生)1面

- 

2025/2/27  货拉拉2面

- 





2025/3/7  腾讯云 测试与质量管理

- http版本、二分查找法插排



准备:

会使用Junit进行单元测试，会使用postman、apifox做接口测试，会使用jmeter进行压力测试，会使用jprofiler做性能分析

jmeter : [JMeter性能测试，完整入门篇教程-CSDN博客](https://blog.csdn.net/weixin_40943297/article/details/96480607)







mysql: 视图、索引创建语句

git: 如何回退，指令

mocktio  判断超时

设计邮箱注册

- ui测试、功能测试、性能测试、兼容性测试、易用性测试









## 雪花算法

雪花算法是Twitter开源的一种分布式ID生成算法，用于在分布式系统中生成全局唯一的ID。其核心思想是将一个64位的长整型ID划分为多个部分，分别表示不同的信息：

- **符号位（1位）**：固定为0，保证ID为正数。
- **时间戳（41位）**：记录ID生成的时间（毫秒级），可用约69年（从1970年算起）。
- **数据中心ID（5位）**：支持最多32个数据中心。
- **机器ID（5位）**：每个数据中心最多32台机器。
- **序列号（12位）**：每台机器每毫秒可生成4096个ID。

#### 2. **优点**

- **全局唯一**：通过时间戳、数据中心ID、机器ID和序列号的组合保证唯一性。
- **趋势递增**：时间戳在高位，生成的ID按时间递增，适合作为数据库主键（避免B+树频繁分裂）。
- **高性能**：本地生成，无网络开销，单机每秒可生成数百万ID。
- **可扩展**：通过配置数据中心和机器ID支持分布式部署。

------

### **弊端与局限性**

#### 1. **时钟回拨问题**

- **问题描述**：雪花算法依赖系统时钟。若**机器时钟因同步（如NTP）或人为调整发生回拨，可能导致生成的ID重复**。

  解决方案

  - **等待时钟恢复**：简单但可能阻塞服务。
  - **记录最后时间戳**：回拨时抛出异常或使用扩展位。
  - **使用逻辑时钟**：如美团Leaf的方案，用独立服务维护时间序列。

#### 2. **机器ID分配问题**

- **依赖人工配置**：数据中心ID和机器ID需手动分配，**易出错且难以动态扩展**。

  改进方案

  - 用ZooKeeper/Etcd动态分配ID。
  - 通过IP或MAC地址哈希自动生成（需避免冲突）。

#### 3. **时间戳耗尽风险**

- 41位时间戳最多支持约69年（`(1L << 41) / (1000 * 60 * 60 * 24 * 365)`），到期后需扩展位数或迁移算法。

#### 4. **多语言实现复杂性**

- 需保证各语言版本逻辑一致（如位操作、时钟处理），增加维护成本。

#### 5. **不适合短生命周期系统**

- 若系统运行时间短（如临时测试环境），时间戳的41位可能浪费。

------

### **替代方案**

1. **数据库自增ID**：简单但性能低，不适合分布式。
2. **UUID**：无序且过长，影响数据库性能。
3. **Redis自增**：性能高但依赖外部服务。
4. **美团的Leaf**：结合雪花算法与数据库优化，解决时钟问题。
5. **MongoDB的ObjectId**：12字节，包含时间戳和机器信息。

------

### **总结**

雪花算法适合高并发、分布式且时钟稳定的场景，但需处理时钟回拨和机器ID分配问题。实际应用中可结合具体需求选择改进方案（如Leaf）或混合策略。



