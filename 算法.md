

# 一、基础算法

## 排序

### 快排

**O(nlogn) - O( n^2 ),  不稳定 **

[快速排序算法—图文详解，一篇就够了！-CSDN博客](https://blog.csdn.net/qq_39181839/article/details/109478094)

左右指针，右指针往左找比左指针小的，甩过去，然后左指针向右找比右指针小的，扔过去，如此循环

**要点:** 

> **找到就扔过去，而不是交换**
>
> **因为第一个元素是哨兵元素（已保存），所以当我们先从右往左扫时，第一次覆盖不会丢失元素**

```java
public void sort(int[]nums, int i, int j){
    if(i >= j){
        return;
    }
    int base = nums[i];
    int left=i, right=j;
    while (left < right) {
        // 注意时 >= 因为相等时我们依然往前走
        while (right > left && nums[right] >= base) {
            right--;
        }
        nums[left] = nums[right];
        while (left < right && nums[left] <= base) {
            left++;
        }
        nums[right] = nums[left];
    }
    //重合点和基准点交换
    nums[left] = base;
    //递归排序
    sort(nums, i, left-1);
    sort(nums, left+1, j);
}
```



时间复杂度分析

- 快速排序最优的情况就是每一次取到的元素都刚好平分整个数组，这种情况下复杂度为**O( nlogn )**

- 最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了，每一次都排好一个元素的顺序 **O( n^2 )**

在大量元素重复的情况下，快排需要为每个重复元素都确认一次位置，可以通过**分区快排**优化

[快速排序不快了？重复元素下的快速排序快速排序，就像它的名字一样，它做排序很快，空间复杂度O(1)下，它的平均时间复杂度为 - 掘金](https://juejin.cn/post/6909316249013092365)



### 堆排

堆排序需要进行下述流程:

- 构造大根/小根堆
- 交换根元素与末尾元素，然后交换之后的末尾元素出堆 (**每次出堆后要限制堆n=n-1** ， 下滤是需注意)
- 对新的根节点下滤维护堆序性

存储结构

![image-20240718171801632](common-image/算法/image-20240718171801632.png)

> 节点下标为 i
>
> 左子节点下标为 2i+1
>
> 右子节点下标为 2i+2
>
> 父节点下标 (i-1)/2

**下滤**

将破环堆序性的节点**与其最大子节点**比较，如果小于其最大子节点，则交换，并对交换后的位置重复上述过程 (下滤递归向下)

```java
 /**
     * 大顶堆
     * 对于i号节点进行下滤操作
     * 即 i节点与最大的子节点交换(如果该节点大于i节点)
     * 时间复杂度   O(logN)
     */
    public static void heapify(int[] array,int n, int i){
        int largest=i;
        int lson=2*i+1;
        int rson=2*i+2;
        if(lson< n && array[largest]<array[lson]){
            largest=lson;
        }
        if(rson< n && array[largest]<array[rson]){
            largest=rson;
        }
        //largest变更，说明有大于i节点的子节点(即为largest)
        if(largest!=i){
            //交换最大子节点和i号元素的位置
            swap(array,i,largest);
            //对largest递归进行下滤操作
            heapify(array,n,largest);
        }

    }
```

> 时间复杂度   O( logN )

**构建堆**

从最大父节点开始，对于每个父节点进行下滤

**堆排序**

按序构建完全二叉树, 然后**从下到上对每个父节点下滤**

 <img src="common-image/算法\image-20240717191537610.png" alt="image-20240717191537610" style="zoom:50%;" />

按需构建堆，然后从下到上，对所有非叶子节点做下滤

```java
    /**
     * 大顶堆
     * 对于i号节点进行下滤操作
     * 即 i节点与最大的子节点交换(如果该节点大于i节点)
     * 时间复杂度   O(logN)
     * @param array
     * @param i
     */
    public static void heapify(int[] array,int n, int i){
        int largest=i;
        int lson=2*i+1;
        int rson=2*i+2;
        if(lson< n && array[largest]<array[lson]){
            largest=lson;
        }
        if(rson< n && array[largest]<array[rson]){
            largest=rson;
        }
        //largest变更，说明有大于i节点的子节点(即为largest)
        if(largest!=i){
            //交换最大子节点和i号元素的位置
            swap(array,i,largest);
            //对largest递归进行下滤操作
            heapify(array,n,largest);
        }

    }

    /**
     * 交换m和n号元素的位置
     */
    public static void swap(int[] array, int m, int n){
        int t=array[m];
        array[m]=array[n];
        array[n]=t;
    }

    /**
     * 建堆 - 大顶堆
     * @param array
     */
    public static void createHeap(int[] array){
        int n=array.length;
        //从最大父节点开始，对于每个父节点进行下滤
        for (int i = n/2-1; i >=0 ; i--) {
            heapify(array,n,i);
        }
        System.out.println(Arrays.toString(array));
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 8, 1, 4, 9, 10, 7, 16, 14};
        headSort(array);
    }

    /**
     * 堆顶和最后的叶子节点交换，并对新的堆顶进行下滤维护堆序性，同时将交换后的最末尾叶子节点(即刚刚的堆顶) 出堆
     * 出堆后，因为堆缩小了，所以该元素不会被操作，即我们依次将堆顶元素固化在了数组尾部
     * 重复上述过程直到堆空
     */
    public static void headSort(int[] array){
        //先构造堆
        createHeap(array);

        int n=array.length;
        //从最末叶子节点开始，同时i也正好为交换一次后，新堆的大小
        for (int i = n-1; i >0 ; i--) {
            //交换堆顶与最末叶子节点
            swap(array,i,0);
            //维护新的堆顶的堆序性
            heapify(array,i,0);
        }
        System.out.println(Arrays.toString(array));

    }
```

**时间复杂度及稳定性**

O(NlogN),  不稳定

> 建堆复杂度为O(N)
>
> heapify复杂度为O(logN)
>
> 堆排序对N个数进行heapify  N*logN







### 插排

[排序算法——直接插入排序（图文超详细！）-CSDN博客](https://blog.csdn.net/qq_44616044/article/details/115708056)



![image-20250307222108898](common-image/算法/image-20250307222108898.png)

代码

```java
public static int[] insertionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        //哨兵元素
        int base = nums[i];
        int j = i - 1;
        //元素后移
        while (j >= 0 && nums[j] > base) {
            nums[j + 1] = nums[j];
            j--;
        }
        //j+1 的位置即为哨兵元素的位置
        nums[j+1] = base;
    }
    return nums;
}
```



### 二分法插排

![image-20250307224214622](common-image/算法/image-20250307224214622.png)

- 二分查找特性（针对**左闭右开**）: **查找结束时，左右指针是重合的，且重合位置是插入位置的下标**(如果要按序插入元素的话) 

```java
public static int[] insertionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        //哨兵元素
        int base = nums[i];
        //二分法查找插入位置
        int index = BinarySearchIndex(nums, 0, i, base);
        //元素后移
        for (int j = i - 1; j >= index; j--) {
            nums[j+1]=nums[j];
        }
        //插入
        nums[index] = base;
    }
    return nums;
}
public static int BinarySearchIndex(int[] nums, int i, int j, int target) 
    int l = i;
    int r = j;
    while (l < r) {
        int mid = (l + r) / 2;
        if (target > nums[mid]) {
            l = mid + 1;
        }else if(target < nums[mid]){
            r = mid;
        }else {
            return mid;
        }
    }
    return l;
}
```



### 归并

- 递归排序左
- 递归排序右
- 合并 (左右区间**合并排序**到temp数组里，然后写回array)

[排序——归并排序（Merge sort）-CSDN博客](https://blog.csdn.net/justidle/article/details/104203958)

```java
public static void main(String[] args) {
    int[] nums = {5, 9, 3, 1, 6, 2, 8, 4, 7};
    sort(nums, 0, nums.length - 1, new int[nums.length]);
    System.out.println(Arrays.toString(nums));
}
public static void sort(int[] arr, int left, int right, int[] temp) {
    //元素只剩一个，直接返回
    if (left == right) return;
    int mid = left + (right - left) / 2;
    sort(arr, left, mid, temp);
    sort(arr, mid + 1, right, temp);
    merge(arr, left, mid, right, temp);
}
// [left, mid] 是集合1，[mid+1, right] 是集合2 , temp数组用来排序，只写不读，排序结果要写回arr
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left;
    int j = mid + 1;
    int k = i;
    //归并排序
    while (i <= mid && j <= right) {
        temp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];
    }
    //移动剩余元素 类似合并两个有序链表那题
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    //在temp的排序结果拷贝回arr
    System.arraycopy(temp, left, arr, left, right - left + 1);
}
```



### 冒泡

每轮移动一个最大的元素到数组尾部

[【排序算法】史上最通俗易懂的【冒泡排序】详解-CSDN博客](https://blog.csdn.net/k_kuo_k/article/details/111650681)

```java
 
        for (int i = 0; i < arr.length - 1; i++) {
            //arr.length - 1 - i是这一轮最大元素要移动到的位置
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
```





## 查找

### 二分查找

- 定义有效区间
- 特性:  查找结束时，左右指针是重合的，且重合位置是插入位置的下标(如果要按序插入元素的话)

针对**有序元素**进行**搜索**, 复杂度O (log n)

```java
/**
 * ! 定义区间 区间的缩小以及while循环的结束都要考虑合法区间是哪里
 * [left,right)
 */
public int searchInsert(int[] nums, int target) {
    int left=0;
    int right=nums.length;
    while (left<right){
        int mid=(left+right)/2;
        if(target>nums[mid]){
            left=mid+1;
        }else if(target<nums[mid]){
            right=mid;
        }else {
            return mid;
        }
    }
    return -1;
}
```





# 二、数据结构

## 哈希

### 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

```java
public static int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i]) && map.get(target - nums[i]) != i) {
            return new int[]{i, map.get(target - nums[i])};
        }
        map.put(nums[i], i);
    }
    return null;
}
```



### 字母异位词分组

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

对字符串排序，异位词排序之后是一样的字符串

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);
    }
    return new ArrayList<>(map.values());
}
```



### 最长连续子序列

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

找序列起始的，如果不是序列起始的就跳过

```java
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<Integer>();
    for (int i = 0; i < nums.length; i++) {
        set.add(nums[i]);
    }
    int max = 0;
    for (Integer num : set) {
        if (set.contains(num - 1)) {
            continue;
        }
        int i = num;
        int count = 1;
        while (set.contains(++i)) {
            count++;
        }
        max = Math.max(max, count);
    }
    return max;
}
```



## 数组

### 移动0

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

### 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/)



### 颜色分类

[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

```java
public void sortColors(int[] nums) {
    int p0 = 0;
    int p1 = 0;
    for (int i = 0; i < nums.length;) {
        if (nums[i] == 0 && i != p0) {
            swap(nums, i, p0);
            p0++;
            p1 = Math.max(p1, p0);
        } else if (nums[i] == 1 && i != p1) {
            swap(nums, i, p1);
            p1++;
        } else {
            i++;
        }
    }
}
public void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```



### 下一个排列

[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

- **下一个数比当前数大** : 低位元素往前找第一个比自己小的，然后交换，这样实现了数的增长
- **增加的幅度尽可能的小**: 交换的小数尽可能地靠右，因为靠左增长的是高位。且交换后交换过去的大数之后应该升序排列，保证之后的元素排列最小

如 [1，2，3，4，3 ] 应该交换 4与3，而不是末尾的3与2

```java
public static void nextPermutation(int[] nums) {
    int maxI = -1;
    int maxJ = -1;
    for (int i = nums.length - 1; i >= 0; i--) {
        //往前找第一个比i小的
        for (int j = i - 1; j >= 0; j--) {
            //找到后先不交换，因为要保证交换时j最大(最靠近低位，这样交换后的数增长最小)
            if (nums[j] < nums[i] && j > maxJ) {
                maxJ = j;
                maxI = i;
            }
        }
    }
    //maxJ == -1 说明原数组降序排列，不需要交换
    if (maxJ != -1) swap(nums, maxI, maxJ);
    //将j之后的数据升序排列 (这里兼顾到了原数组降序排列的情况)
    Arrays.sort(nums, maxJ + 1, nums.length);
}
public static void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```





### 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

![image-20240929001156357](common-image/算法\image-20240929001156357.png)

- 先按照左端点排序，排序完后只需要考虑当前节点能否向前合并即可;

```java
public int[][] merge(int[][] intervals) {
    List<int[]>result=new ArrayList<>();
    Arrays.sort(intervals, (p, q) -> p[0] - q[0]);
    int left=0;
    int right=0;
    int fast=1;
    result.add(intervals[0]);
    while (fast<intervals.length){
        int[] cur= intervals[fast];
        //后续区间左边界小于右边界right
        if(cur[0]<=intervals[left][1] ){
            //后续区间右边界大于原右边界 有效的合并
            if(cur[1]>=intervals[right][1]){
                int[] merge = result.get(result.size() - 1);
                //向右拓展合并
                merge[1]=cur[1];
                right=fast;
            }
            //无法合并
        }else {
            result.add(cur);
            //left，right指针更新
            left=fast;
            right=fast;
        }
        fast++;
    }
    return  result.toArray(new int[result.size()][]);
}
```





### 轮转数组

[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

#### 解法一: 三次翻转

```java
public void rotate(int[] nums, int k) {
    k=k%nums.length;
    if(k==0)return;
    flip(nums,0,nums.length-1);
    flip(nums,0,k-1);
    flip(nums,k,nums.length-1);
}
public void flip(int[]nums,int i,int j){
    int left=i;
    int right=j;
    while (left<right){
        int temp=nums[left];
        nums[left]=nums[right];
        nums[right]=temp;
        left++;
        right--;
    }
}
```

#### 解法二：双指针

```java
public void rotate(int[] nums, int k) {
    k=k%nums.length;
    if(k==0)return;
    int[] array=new int[nums.length];
    //移动 nums.length 次，nums轮转拷贝到array里
    for (int i = nums.length-k, j=0; j < nums.length; j++,i=++i % nums.length) {
        array[j]=nums[i];
    }
    //array拷贝回nums
    for (int i = 0; i < nums.length; i++) {
        nums[i]=array[i];
    }
}
```



### 缺失的第一个正数

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

**示例 **

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

将数组做“原地hash”，把所有元素交换到与下标对应的位置上，第一个下标与元素不对应的，就是第一个缺失的

- `nums[i] >= 1 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]` 该位置元素在区间内，且该位置元素对应的位置上并不是正确的元素，才需要交换
- 交换后不需要前进，不然可能交换后漏掉当前位置的元素 (类似于删除链表元素)

![0041-14.png](https://pic.leetcode-cn.com/1e4f3f1c9a6fb37c2aa515069508f5f3ef9d72cc55b586790f9bec9705052d17-0041-14.png)



```java
public static int firstMissingPositive(int[] nums) {
    for (int i = 0; i < nums.length; ) {
        //该位置元素在区间内，且该位置元素对应的位置上并不是正确的元素
        if (nums[i] >= 1 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]) {
            swap(nums, nums[i] - 1, i);
            //交换后不需要前进，不然可能交换后漏掉当前位置的元素
        } else {
            i++;
        }
    }
    for (int i = 0; i < nums.length; i++) {
        if (i != nums[i] - 1) {
            return i + 1;
        }
    }
    return nums.length + 1;
}
```





## 矩阵

### 搜索二维矩阵

[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

![image-20250309222423557](common-image/算法/image-20250309222423557.png)

- 从右上角向左下角，向左变小，向右变大

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int top = 0;
    int right = matrix[0].length - 1;
    while (top < matrix.length && right >= 0) {
        if (target < matrix[top][right]) {
            right--;
        } else if (target > matrix[top][right]) {
            top++;
        } else {
            //缩小后的顶点正好在目标值
            return true;
        }
    }
    return false;
}
```



### 矩阵置0

给定一个 `m* x n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

- 使用标记数组`zeroRow` 和 `zeroCol` 记录应该置0的行和列，再遍历一次矩阵将 `zeroRow[i] || zeroCol[j]` 的位置置为0

```java
public void setZeroes(int[][] matrix) {
    boolean[] zeroRow=new boolean[matrix.length];
    boolean[] zeroCol=new boolean[matrix[0].length];
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] == 0) {
                zeroRow[i]=true;
                zeroCol[j]=true;
            }
        }
    }
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            if (zeroRow[i] || zeroCol[j]) {
                matrix[i][j]=0;
            }
        }
    }
    
}
    
public boolean legitX(int x,int[][] matrix){
    return matrix.length>x && x>=0;
}
public boolean legitY(int y,int[][] matrix){
    return matrix[0].length>y && y>=0;
}
```







### 螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

![image-20241006221439840](common-image/算法\image-20241006221439840.png)

- 每遍历完一行或者一列，更新其边界，直到边界交错退出

```java
public List<Integer> spiralOrder(int[][] matrix) {
    int top=0;
    int bottom=matrix[0].length-1;
    int left=0;
    int right=matrix.length-1;
    List<Integer> result=new ArrayList<>();
    while (true){
        //向右
        for (int i = left; i <=right; i++) result.add(matrix[top][i]);
        //上边界下缩
        if(++top>bottom)break;
        //向下
        for (int i = top; i <=bottom; i++) result.add(matrix[i][right]);
        //右边界左缩
        if(--right<left)break;
        //向左
        for (int i = right; i >=left; i--) result.add(matrix[bottom][i]);
        //下边界上缩
        if(--bottom>top)break;
        //向上
        for (int i = bottom; i >=top; i--) result.add(matrix[i][left]);
        //左边界右缩
        if(++left>right)break;
    }
    return result;
}
```









## 栈

### 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

> **示例 2：**
>
> **输入：**s = "()[]{}"
>
> **输出：**true

```java
public boolean isValid(String s) {
    Stack<Character> stack=new Stack<>();
    if(s.charAt(0)==')' ||s.charAt(0)=='}' ||s.charAt(0)==']')return false;
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        //当前为左括号
        if(c=='(' ||c=='{' ||c=='['){
            stack.push(c);
            //当前为右括号,stack不空,且匹配上了
        } else if (!stack.isEmpty() && match(c,stack.peek())) {
            stack.pop();
            // //当前为右括号且stack空
        }else {
            return false;
        }
    }
    return stack.isEmpty();
}
//右括号a 与 左括号b 是否匹配
public boolean match(char r,char l){
    return (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');
}
```



### 最小栈

[155. 最小栈](https://leetcode.cn/problems/min-stack/)





### 字符串解码

[394. 字符串解码](https://leetcode.cn/problems/decode-string/)

```java
public String decodeString(String s) {
    char[] chars = s.toCharArray();
    Stack<Integer> stack_nums = new Stack<>();
    Stack<String> stack_string = new Stack<>();
    StringBuilder cur = new StringBuilder();
    int mult = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] == '[') {
            stack_nums.push(mult);
            stack_string.push(cur.toString());
            cur.delete(0, cur.length());
            mult = 0;
        } else if (chars[i] == ']') {
            int nums = stack_nums.pop();
            StringBuilder prev = new StringBuilder(stack_string.pop());
            for (int j = 0; j < nums; j++) {
                prev.append(cur);
            }
            cur = prev;
        } else if (Character.isDigit(chars[i])) {
            mult = Integer.parseInt("" + chars[i]) + mult * 10;
        }else{
            //字母
            cur.append(chars[i]);
        }
    }
    return cur.toString();
}
```



## 链表

### 核心

- 设置`dumpyHead`节点，避免额外操作头节点

- 删除/插入等操作，指针应该指向要删除/插入等**元素的上一位**

- 返回结果应返回 `dumpyHead.next`, 因为`Head`可能已经被删除了

### 链表构造

```java
public class ListNode {
    public int val;
    public ListNode next;

    public ListNode() {
    }

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```



### 移除链表-常规遍历

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode dumpyHead=new ListNode();
    dumpyHead.next=head;
    ListNode node=dumpyHead;
    while (node.next!=null){
        if(node.next.val==val){
            node.next=node.next.next;
        }else {
            node=node.next;
        }
    }
    return dumpyHead.next;
}
```

- 指针应指向要删除元素的上一位，因此指针最多向后移动到尾元素前一位，**遍历范围 `node.next!=null`**
- **删除后不应该立即挪动指针**，因为新连接的节点(指针后一个)也可能是要删除的元素

### 相交链表

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

**解法一：Hash**

```java
/**
 * set集合解法
 */
public ListNode getIntersectionNodeHash(ListNode headA, ListNode headB) {
    Set<ListNode> set=new HashSet<>();
    //开始遍历A，节点加入set集合
    ListNode node=headA;
    while (node!=null){
        set.add(node);
        node=node.next;
    }
    //遍历B，知道找到set集合中第一个包含的元素
    node=headB;
    while (node!=null && !set.contains(node)){
        node=node.next;
    }
    return node;
}
```



**解法二: 数学法**

链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m，b+c=n。

在**指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点**，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。

```java
/**
 * 数学法
 */
public ListNode getIntersectionNodePointer(ListNode headA, ListNode headB) {
    ListNode nodeA=headA;
    ListNode nodeB=headB;
    //不相交,nodeA,nodeB同时走到null
    //相交，nodeA,nodeB同时走到公共节点
    while (nodeA!=nodeB){
        nodeA=nodeA==null?headB:nodeA.next;
        nodeB=nodeB==null?headA:nodeB.next;
    }
    return nodeA;
}
```

### 反转链表-递归/迭代

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表

![image-20240927102654398](common-image/算法\image-20240927102654398.png)

- 递归翻转`cur.next`，直到翻转到尾节点
- **返回的始终是尾节点(这样就能一直持有翻转后的首节点)**，新的连接关系通过`cur.next.next=cur`设置

```java
public ListNode reverseList(ListNode head) {
    //遇到尾节点直接返回即可
    if(head==null || head.next==null)return head;
    ListNode cur=head;
    //翻转后的尾节点ret
    ListNode ret = reverseList(cur.next);
    //关系翻转
    cur.next.next=cur;
    cur.next=null;
    return ret;
}
```

**迭代解法**

![image-20240927202153213](common-image/算法\image-20240927202153213.png)

- **cur转头连prev，cur向前移(cur=next，next需要在一开始就纪录)**

```java
 public ListNode reverseList(ListNode head) {
     ListNode cur=head;
     ListNode prev=null;
     while (cur!=null){
         ListNode next=cur.next;
         //转头连前面的
         cur.next=prev;
         //记录当前为prev
         prev=cur;
         //下轮 cur为上轮记录的next
         cur=next;
     }
     return prev;
 }
```



### 找中间节点-快慢指针

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

![image-20240927105320542](common-image/算法\image-20240927105320542.png)

如果有两个中间结点，则返回第二个中间结点。

- **快指针走两步，慢指针走一步，快指针到头，慢指针指向中间节点**

```java
public ListNode middleNode(ListNode head) {
    ListNode slow=head;
    ListNode fast=head;
    //这里如果fast走到了null，slow会正好指向中间节点，就不需要 return slow.next 来返回第二个了
    while (fast!=null && fast.next!=null){
        slow=slow.next;
        fast=fast.next.next;
    }
    return slow;
}
```

### 回文链表

[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表

如果是，返回 `true` ；否则，返回 `false` 。

 

![image-20240927110856324](common-image/算法\image-20240927110856324.png)



**找到中间节点，翻转后半部分，比较翻转完的后半部分和前半部分**

```java
public boolean isPalindrome(ListNode head) {
        //快慢指针找中间节点
        if(head.next==null)return true;
        ListNode slow=head;
        ListNode fast=head;
        while (fast!=null && fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }
        //找到中间节点slow,对slow做翻转
        ListNode ret=reverse(slow);
        ListNode pointer1=head;
        ListNode pointer2=ret;
        //比较反转后的后半部分和前半部分
        while (pointer2!=null && pointer1.val==pointer2.val){
            pointer1=pointer1.next;
            pointer2=pointer2.next;
        }
        //如果遍历到了null，说明前面都是匹配的
        return pointer2==null;


    }

    public ListNode reverse(ListNode head){
        if(head.next==null)return head;
        ListNode ret = reverse(head.next);
        head.next.next=head;
        head.next=null;
        return ret;
    }
```

### 环形链表Ⅰ-有无环

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

![image-20240927111839000](common-image/算法\image-20240927111839000.png)

**快慢指针 ， 快指针走两步，慢指针走一步 ，快慢重合说明有环**

```java
public boolean hasCycle(ListNode head) {
    if(head==null || head.next==null) return false;
    ListNode slow=head;
    ListNode fast=head.next;
    //fast不为空且slow和fast不相等
    while ( fast!=null && fast.next!=null && slow!=fast ){
        slow=slow.next;
        fast=fast.next.next;
    }
    return slow==fast;
}
```

### 环形链表Ⅱ-环的入口

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)



![image-20240927115408394](common-image/算法\image-20240927115408394.png)

```java
public ListNode detectCycle(ListNode head) {
    //合法检查
    if(head==null)return null;
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    //快慢指针 快指针走2步，慢指针走1步
    ListNode fast = dummyHead, slow = dummyHead;
    while (fast.next!=null&&fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            //有环,则让使用两指针index1(头节点)和index2(相遇点)同速走，相遇位置即为环的入
            ListNode index1 = dummyHead, index2 = fast;
            while (index2!=index1){
                index2=index2.next;
                index1=index1.next;
            }
            return index1;
        }
    }
     return null;
}
```



### 合并有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

 **解法-递归**

从两个链表中选个小的当头节点，合并剩下的链表，返回合并后的头节点，两个节点相连

- 边界条件 : `list1=null` 或者 `list2=null` 时，说明只剩下一个链表，拼接该链表即可

 <img src="common-image/算法\image-20240927122412210.png" alt="image-20240927122412210" style="zoom: 67%;" />

 <img src="common-image/算法\image-20240927122426750.png" alt="image-20240927122426750" style="zoom:67%;" />



```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if(list1==null){
        return list2;
    }
    if(list2==null){
        return list1;
    }
    // list2头节点较小
    if(list1.val>= list2.val){
        ListNode next = mergeTwoLists(list1, list2.next);
        list2.next=next;
        return list2;
    }else {
        ListNode next = mergeTwoLists(list1.next, list2);
        list1.next=next;
        return list1;
    }
}
```





### 两数相加



- 记录**进位**
- 和**取余数**来获取个位

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![image-20240927173556647](common-image/算法\image-20240927173556647.png)



```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
     ListNode point1=l1;
    ListNode point2=l2;
    int carry=0;
    ListNode dumpyHead=new ListNode();
    ListNode node=dumpyHead;
    //如果最后有进位也要计算一次
    while (point2!=null || point1!=null|| carry!=0){
        int l1Count= point1!=null?point1.val:0;
        int l2Count= point2!=null?point2.val:0;
        int count=l1Count+l2Count+carry;
        node.next=new ListNode(count % 10);
        //记录进位
        carry=count>=10?1:0;
        //后移
        point1=point1!=null?point1.next:point1;
        point2=point2!=null?point2.next:point2;
        node=node.next;
    }
    return dumpyHead.next;
}
```

### 删除倒数第n个

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

- **`快慢指针` **: **快指针先走n步，然后快慢一起走直到快指针走到尾巴**，慢指针就走到了倒数第n个

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dumpyHead=new ListNode();
    dumpyHead.next=head;
    ListNode slow=dumpyHead;
    ListNode fast=dumpyHead;
    //先走n步
    for (int i = 0; i < n; i++) {
        fast=fast.next;
    }
    //一直走到fast到尾节点
    while (fast.next!=null){
        slow=slow.next;
        fast=fast.next;
    }
    //删除slow指针后一个元素
    slow.next=slow.next.next;
    return dumpyHead.next;
}
```



#### - 旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

同链表倒数第K个

```java
public ListNode rotateRight(ListNode head, int k) {
    if(head == null || head.next == null || k == 0){
        return head;
    }
    ListNode cur = head;
    int size = 0;
    while (cur != null) {
        cur = cur.next;
        size++;
    }
    k = k % size;
    if (k == 0) {
        return head;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    //快慢指针找到倒数第k+1个节点
    for (int i = 0; i < k + 1 && fast != null; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    //第k个作为新的头节点
    ListNode newHead = slow.next;
    slow.next = null;
    //快指针指向尾节点
    fast = newHead;
    while (fast.next != null) {
        fast = fast.next;
    }
    fast.next = head;
    return newHead;
}
```







### 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

![image-20240927175521797](common-image/算法\image-20240927175521797.png)

- **`递归`**, 交换当前组后，连接后续s交换完的头节点

```java
public ListNode swapPairs(ListNode head) {
    //当前组为空或者只有一个，直接返回
    if(head==null || head.next==null)return head;
    ListNode nextNode=head.next;
    //交换后续节点
    ListNode swapped = swapPairs(head.next.next);
    head.next=swapped;
    nextNode.next=head;
    return nextNode;
}
```

**迭代**

令 temp 表示当前到达的节点，初始时 temp = dummyHead。**每次需要交换 temp 后面的两个节点**。

如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。

新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null && temp.next.next != null) {
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;
            temp.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            temp = node1;
        }
        return dummyHead.next;
    }
}
```



### 排序链表



```javascript
public ListNode sortList(ListNode head) {
    if(head==null || head.next==null)return head;
    ListNode fast=head;
    ListNode slow=head;
    while (fast.next!=null && fast.next.next!=null){
        slow=slow.next;
        fast=fast.next.next;
    }
    //断开连接
    ListNode temp=slow.next;
    slow.next=null;
    //分别
    ListNode left = sortList(head);
    ListNode right = sortList(temp);
    //merge构造新链表
    ListNode dumpyHead=new ListNode();
    ListNode node=dumpyHead;
    while (left!=null && right!=null){
        if(left.val<right.val){
            node.next=left;
            left=left.next;
        }else {
            node.next=right;
            right=right.next;
        }
        node=node.next;
    }
    node.next=left==null?right:left;
    return dumpyHead.next;
}
```





### 手撕LRU

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}
```

**LinkedHashMap** 提供了按照**访问**顺序排序的功能，这使得它可以非常方便地实现LRU缓存。 当 **LinkedHashMap** 的构造函数中的 accessOrder 参数设置为 true 时，每次**访问**一个元素（通过 get 或 put），该元素都会被移到链表的尾部。

**方法一：哈希表 + 双向链表**

- 哈希表用来提供按照key进行访问

- 双向链表负责维护最近使用的，每次使用移动到尾部 `头部最久未用，尾部最近使用`

!在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。

![image-20240928162525760](common-image/算法\image-20240928162525760.png)



对于 get 操作，首先判断 key 是否存在：

- 如果 key 不存在，则返回 −1；

- 如果 key 存在，移动到尾部，返回值

对于 put 操作，首先判断 key 是否存在：

- 如果 key 不存在，尾部添加该节点，添加进哈希表中。判断双向链表的节点数是否超出容量
  - 如果超出容量，则删除双向链表的头部节点，并删除哈希表中对应的项；

- 如果 key 存在，**节点的值更新为 value，移到尾部**。



**建议print()打印, 并将map操作封装在removeHead，putTail操作中**

最好先写注释，在根据注释写代码

```java
public class LRUCache {
    
    int capacity;
    int size;
    LinkListNode dumpyHead;
    LinkListNode dumpyTail;
    Map<Integer, LinkListNode> map = new HashMap<>();

    class LinkListNode {
        LinkListNode prev;
        LinkListNode next;
        Integer key;
        Integer val;

        public LinkListNode(int key, int val) {
            this.key = key;
            this.val = val;
        }

        public LinkListNode() {
        }
    }

    

    public LRUCache(int capacity) {
        dumpyHead = new LinkListNode();
        dumpyTail = new LinkListNode();
        dumpyHead.next = dumpyTail;
        dumpyTail.prev = dumpyHead;
        this.capacity = capacity;
    }

    public int get(int key) {;
        if (!map.containsKey(key))return -1;
        LinkListNode node = map.get(key);
        moveToTail(node);
        print();
        return node.val;
    }

    public void put(int key, int value) {
        //已经存在更新node
        if (map.containsKey(key)) {
            //更新并移动到尾部
            LinkListNode node = map.get(key);
            node.val = value;
            moveToTail(node);
            //不存在，则插入
        } else {
            //插入尾部
            putTail(new LinkListNode(key, value));
            ++size;
            //超出容量限制
            if (size > capacity) {
                //移除头部
                removeHead();
            }
        }
    }

    public LinkListNode removeHead() {
        LinkListNode first = dumpyHead.next;
        dumpyHead.next=first.next;
        first.next.prev=dumpyHead;
        first.next=null;
        first.prev=null;
        size--;
        map.remove(first.key);
        return first;
    }

    public void putTail(LinkListNode node) {
        LinkListNode last = dumpyTail.prev;
        last.next=node;
        node.prev=last;
        node.next=dumpyTail;
        dumpyTail.prev=node;
        map.put(node.key,node);
    }

    public void moveToTail(LinkListNode node){
        //断开前后
        LinkListNode ahead=node.prev;
        ahead.next=node.next;
        ahead.next.prev=ahead;
        //移动到尾
        LinkListNode last = dumpyTail.prev;
        last.next=node;
        node.prev=last;
        node.next=dumpyTail;
        dumpyTail.prev=node;
    }
    
    public void print(){
        LinkListNode node=dumpyHead;
        while (node!=null){
            System.out.println(node.key+" : "+node.val);
            node=node.next;
        }
    }


}
```









## 二叉树

 ![image-20250109153839343](common-image/算法\image-20250109153839343.png)

### dfs

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [145.二叉树的后序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

#### **递归遍历**-前中后

```java
public TreeNode traverse_recursion(TreeNode root){
    if(root==null)return root;
    System.out.println(root.val);
    traverse_recursion(root.left);
    traverse_recursion(root.right);
    return root;
}
```



#### **迭代遍历**-栈-前后

![二叉树前序遍历（迭代法）](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

**先序遍历**

```java
public void traverse_iteration(TreeNode root){
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode cur = stack.pop();
            //操作根节点 先根
            System.out.println(cur.val);
            if(cur.left!=null){
                stack.push(cur.left);
            }
            if(cur.right!=null){
                stack.push(cur.right);
            }
        }
    }
```

**后序遍历**

- 实际上就是先按 `中右左` 遍历 , 用集合收集，最后倒叙遍历集合

```java
public void traverse_iteration(TreeNode root){
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
    	List<TreeNode> list=new ArrayList();
        while (!stack.isEmpty()){
            TreeNode cur = stack.pop();
            //根先存入集合
            list.add(cur);
            if(cur.right!=null){
                stack.push(cur.right);
            }
            if(cur.left!=null){
                stack.push(cur.left);
            }
        }
    	//倒序遍历就变成左右中了
    	reverse(list);
    }

```



#### NULL 标记法迭代

**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记**

![中序遍历迭代（统一写法）](https://code-thinking.cdn.bcebos.com/gifs/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif)

可以理解为，遇到一个节点，如果不为空，就把他弹出来，将他与他子节点排序后存入栈，并将该节点后面加个NULL表示该节点可以被处理了

通过将该节点与其子节点排序的方式，解决节点访问与处理顺序不一致的问题

```java
//中序-迭代法
public List<Integer> traversalMid(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if(root==null){
        return res;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        TreeNode top = stack.peek();
        if(top!=null){
            stack.pop();
            if(top.right!=null){
                stack.push(top.right);
            }
            stack.push(top);
            stack.push(null);
            if(top.left!=null){
                stack.push(top.left);
            }
        }else {
            stack.pop();
            TreeNode pop = stack.pop();
            res.add(pop.val);
        }
    }
    return res;
}
```



### bfs

[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
public void traverse_level(TreeNode root){
    Queue<TreeNode> queue=new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()){
        TreeNode poll = queue.poll();
        if(poll.left!=null){
            queue.add(poll.left);
        }
        if(poll.right!=null){
            queue.add(poll.right);
        }
    }
}
```

- [102.二叉树的层序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- [107.二叉树的层次遍历II(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
- [199.二叉树的右视图(opens new window)](https://leetcode.cn/problems/binary-tree-right-side-view/)
- [637.二叉树的层平均值(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
- [429.N叉树的层序遍历(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
- [515.在每个树行中找最大值(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
- [116.填充每个节点的下一个右侧节点指针(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
- [117.填充每个节点的下一个右侧节点指针II(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
- [104.二叉树的最大深度(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### 高度与深度

![image-20250109165623871](common-image/算法\image-20250109165623871.png)

**! 根节点的高度即为二叉树的最大深度**

求深度应该用bfs，求高度应该用dfs

### Hot100

[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

1、层次遍历求深度

2、转为求根节点高度

<img src="common-image/算法\image-20240927210947406.png" alt="image-20240927210947406" style="zoom:67%;" />



```java
public int maxDepth(TreeNode root) {
    //null节点返回0
    if(root==null)return 0;
    int left = getHeight(root.left);
    int right = getHeight(root.right);
    //叶子节点返回1
    if(left==0 && right==0) return 1;
    //取左右子数高度，并加1
    return Math.max(left, right)+1;
}
```

#### 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

- 递归，翻转左子，翻转右子，翻转完后左右换位

```java
public TreeNode invertTree(TreeNode root) {
    if(root==null)return null;
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.right =left;
    root.left = right;
    return root;
}
```



#### 对称二叉树



给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

![Picture1.png](https://pic.leetcode-cn.com/1599398062-PbkpuX-Picture1.png)

- 递归
- **每个节点只比较和自己镜像的**，同时递归判断（交给下层）左右节点是否都为镜像 (**外侧相等** && **内侧相等**)

```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}
public boolean isMirror(TreeNode left, TreeNode right) {
    //左右均空返回true
    if((left==null && right==null))return true;
    //仅一个为空返回false
    if(!( left!=null && right!=null))return false;
    //比较外侧
    boolean out = isMirror(left.left, right.right);
    //比较内侧
    boolean in = isMirror(left.right, right.left);
    //本层相等
    return left.val==right.val && out && in;
}
```



#### 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

- 递归求深度，**每个节点计算一次 `左子树的最大深度+右子树的最大深度 (相当于经过该节点的最长路径)`** ， 和最大路径长度比较

```java
int length=0;
public int diameterOfBinaryTree(TreeNode root) {
    maxDepth(root);
    return length;
}
public int maxDepth(TreeNode root){
    if(root==null)return 0;
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    length=Math.max(length,left+right);
    return Math.max(left,right)+1;
}
```



#### 有序数组转二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **`升序`** 排列，请你将其转换为一棵 `平衡二叉搜索树`。

![image-20240928112302989](common-image/算法\image-20240928112302989.png)

![image-20240928112413959](common-image/算法\image-20240928112413959.png)

- **递归，中间节点作为根，递归构建左子树和右子树**

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return bst(nums, 0, nums.length - 1);
}
public TreeNode bst(int[] nums,int left,int right) {
    //终止条件
    if(left>right)return null;
    if(left==right)return new TreeNode(nums[left]);
    int mid=(left+right)/2;
    TreeNode root=new TreeNode(nums[mid]);
    root.left=bst(nums,left,mid-1);
    root.right=bst(nums,mid+1,right);
    return root;
}
```



#### 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

<img src="common-image/算法\image-20240928112601079.png" alt="image-20240928112601079" style="zoom:67%;" />

- **递归，每层只考虑自身是不是在上层递归给自己设的上下限中**
- 递归判断左右子节点，**对于左子节点，应该更新当前节点为上限; 右子节点相反**

```java
 public boolean isValidBST(TreeNode root) {
    return validBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
 }
 public boolean validBST(TreeNode root,Long lower,Long upper) {
     if(root==null)return true;
     if(root.val<=lower || root.val>=upper ){
         return false;
     }
     return validBST(root.left,lower,root.val) && validBST(root.right,root.val,upper);
 }
```





#### 二叉搜索树中第k小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素

<img src="common-image/算法\image-20240928120644513.png" alt="image-20240928120644513" style="zoom:67%;" />

- 中序遍历，每遍历一个节点count++，判断是否为k即可

```java
int count=0;
Integer result=null;
public int kthSmallest(TreeNode root, int k) {
    traverse(root,k);
    return result;
}
public void traverse(TreeNode root,int k) {
    if(root==null)return;
    traverse(root.left,k);
    if(result!=null)return;
    if(++count==k){
        result=root.val;
        return;
    }
    traverse(root.right,k);
}
```





#### 最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。(**一个节点也可以是它自己的祖先**)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```



![image-20240928170039671](common-image/算法\image-20240928170039671.png)

- 递归，当一个节点 (`左边找到了指定节点 && 右边找到了指定节点`) -》祖先

```java
TreeNode target;
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    getCommon(root,p,q);
    return target;
}
public boolean getCommon(TreeNode root, TreeNode p, TreeNode q) {
    if(root==null)return false;
    if(target!=null)return true;
    boolean left = getCommon(root.left, p, q);
    boolean right = getCommon(root.right, p, q);
    boolean cur=(p.val==root.val || q.val==root.val);
    if(target!=null)return true;
    //这里额外判断了自身即是要找的节点同时也是祖先的情况
    if(left && right || (left && cur) || ( right && cur)) target=root;
    return left || right || cur;
}
```







#### 从前序与中序遍历构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点

- 递归，前序首位为根，通过中序遍历计算左子树长度 leftLength，前序中 preLeft + leftLength 可得到右子树根
- 核心：找前序数组的左右分割点，分割构建左右子树

![image-20240928173500059](common-image/算法\image-20240928173500059.png)

**在纸上画四个边界指针的缩小情况**

```java
Map<Integer,Integer> map=new HashMap<>();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i],i);
    }
    TreeNode root = build(preorder, inorder, 0, preorder.length - 1, 0, preorder.length - 1);
    return root;
}
public TreeNode build(int[]preorder,int[] inorder,int pLeft,int pRight,int iLeft,int iRight) {
    if(pRight<pLeft || iLeft >iRight || pLeft < 0)return null;
    TreeNode root = new TreeNode(preorder[pLeft]);
    //计算左子树长度
    int iIndex = map.get(preorder[pLeft]);
    int leftSize=iIndex-iLeft;
    root.left=build(preorder,inorder,pLeft+1,pLeft+leftSize,iLeft,iIndex-1);
    root.right=build(preorder,inorder,pLeft+leftSize+1,pRight,iIndex+1,iRight);
    return root;
}
```





#### 二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="common-image/算法\image-20240929154650440.png" alt="image-20240929154650440" style="zoom:67%;" />

法一: 前序遍历，先遍历右节点，每次达到了新的深度，说明当前节点一定是最右最深节点。

法二: 层序遍历，收集每层最右节点





#### 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

<img src="common-image/算法\image-20240929160754450.png" alt="image-20240929160754450" style="zoom:67%;" />



- 迭代

```java
public void flatten(TreeNode root) {
        if(root==null)return;
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        //第一个为哑元节点
        TreeNode cur=new TreeNode();
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            //连接成链
            cur.left=null;
            cur.right=pop;
            if(pop.right!=null)stack.push(pop.right);
            if(pop.left!=null)stack.push(pop.left);
            //pop作为新的cur
            cur=pop;
        }
    }
```

- 递归

注意是**注意指针的更新顺序，以及一开始要保存左右指针**

```java
public void flatten(TreeNode root) {
    if(root==null)return;
    dfs(root);
}
public TreeNode dfs(TreeNode root) {
    TreeNode left = root.left;
    TreeNode right = root.right;
    TreeNode last=root;
    if(root.left!=null){
        last =dfs(left);
        root.right=root.left;
    }
    if(right!=null){
        last.right=right;
        last =dfs(right);
    }
    root.left=null;
    return last;
}
```





#### 路径总和3

**前缀和+hashmap回溯**

![image-20240928215957815](common-image/算法\image-20240928215957815.png)

**从顶到底计算前缀，在map中找有无前缀和等于pre-targetSum**

```java
//key:前缀和 value:个数 
Map<Long, Integer> map = new HashMap<>();
 int count = 0;
 public int pathSum(TreeNode root, int targetSum) {
     map.put(0L, 1);
     traverse(root, targetSum, 0);
     return count;
 }
//pre是上个节点累加的前缀和
 public void traverse(TreeNode root, int targetSum, long pre) {
     if (root == null) return;
     pre += root.val;
     count += map.getOrDefault(pre - targetSum, 0);
     map.merge(pre, 1, Integer::sum);
     traverse(root.left, targetSum, pre);
     traverse(root.right, targetSum, pre);
     //回溯时恢复前缀和
     map.merge(pre, -1, Integer::sum);
 }
```



#### 最大路径和

[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```



解法:

![image-20250309231041314](common-image/算法/image-20250309231041314.png)

```java
//全局最大和
private int max = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    return Math.max(traverse(root), max);
}

public int traverse(TreeNode root) {
    if (root == null) return 0;
    int left = traverse(root.left);
    int right = traverse(root.right);
    //以当前节点为左右子节点的连接, 选4种情况最大的
    max = getMax(root.val, left + root.val, right + root.val, left + right + root.val, max);
  	//只能连左/右
    return getMax(root.val, left + root.val, right + root.val);
}

public static int getMax(int... nums) {
    return Arrays.stream(nums).max().getAsInt();
}
```



优化：只计算贡献值，效率差不多

```java
private int max = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
    traverse(root);
    return max;
}
public int traverse(TreeNode root) {
    if (root == null) return 0;
    int leftGain = Math.max(traverse(root.left), 0);
    int rightGain = Math.max(traverse(root.right), 0);
    max = Math.max(root.val + rightGain + leftGain, max);
    return root.val + Math.max(leftGain, rightGain);
}
```







## 图论

### 理论基础

#### 图的存储

邻接矩阵

邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

例如： grid[2,5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。

如果想表示无向图，即：grid[2,5] = 6，grid[5,2] = 6，表示节点2 与 节点5 相互连通，权值为6。

<img src="common-image/算法\image-20240930114240169.png" alt="image-20240930114240169" style="zoom:50%;" />

邻接表

这里表达的图是：

- 节点1 指向 节点3 和 节点5
- 节点2 指向 节点4、节点3、节点5
- 节点3 指向 节点4
- 节点4指向节点1

![image-20240930114406424](common-image/算法\image-20240930114406424.png)

#### 搜索



### 所有可能的路径

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。



<img src="common-image/算法\image-20240930110121085.png" alt="image-20240930110121085" style="zoom:50%;" />

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

深搜

```java
public List<Integer> path=new ArrayList<>();
public List<List<Integer>> result=new ArrayList<>();
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    path.add(0);
    backtracking(graph,0,graph.length-1);
    return result;
}
//graph:邻接矩阵， x:当前节点， n:目的节点
public void backtracking(int[][]graph,int x,int n){
    if(x==n){
        result.add(new ArrayList<>(path));
        return;
    }
    for (int j = 0; j < graph[x].length; j++) {
        int cur = graph[x][j];
        path.add(cur);
        backtracking(graph,cur,n);
        path.remove(path.size()-1);
    }
}
```



### 网格问题

#### 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```



```java
public int numIslands(char[][] grid) {
    int count = 1;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == '1') {
                count++;
                //标记岛屿为count
                dfs(i, j, grid, count);
            }
        }
    }
    return count-1;
}
//第一次dfs标记岛屿为2
public void dfs(int row, int col, char[][] grid, int count) {
    //越界或者遍历到了非1网格
    if (!legit(row, col, grid) ||grid[row][col] != '1' ) {
        return;
    }
    grid[row][col] = '2';
    //向四个方向遍历
    dfs(row + 1, col, grid, count);
    dfs(row - 1, col, grid, count);
    dfs(row, col - 1, grid, count);
    dfs(row, col + 1, grid, count);
}
public boolean legit(int row, int col, char[][] grid) {
    return row >= 0 && col >= 0 && row < grid.length && col < grid[row].length;
}
```



#### 单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

- dfs遍历，通过标记数组记录路径避免走重复的路

```java
public boolean exist(char[][] board, String word) {
    boolean[][]tag =new boolean[board.length][board[0].length];
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if(board[i][j]==word.charAt(0) && dfs(i,j,0,word,board,tag)){
                return true;
            }
        }
    }
    return false;
}
//字符串的index位与当前网格字符是否相等
public boolean dfs(int row, int col, int index, String word, char[][]board, boolean[][]tag){
    //index走到了word.length,说明全匹配上了
    if(index>=word.length()){
        return true;
    }
    //不合法或不相等，返回
    if(!legit(row,col,board) || word.charAt(index)!=board[row][col] || tag[row][col]){
        return false;
    }
    tag[row][col]=true;
    boolean success= dfs(row+1,col,index+1,word,board,tag)
            || dfs(row-1,col,index+1,word,board,tag)
            || dfs(row,col+1,index+1,word,board,tag)
            || dfs(row,col-1,index+1,word,board,tag);
    //回溯
    tag[row][col]=false;
    return success;
}
public boolean legit(int row,int col,char[][]board){
    return row>=0 && col>=0 && row<board.length && col<board[0].length;
}
```







#### 腐烂的橘子

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

![image-20241001155419156](common-image/算法\image-20241001155419156.png)

```
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

- `core`: BFS广搜，for循环一批一批弹出处理，这样能保证这一批在同一时刻腐化
- 细节: **入队列前判断是否合法且新鲜，出队列处理时判断是否新鲜(有可能被其他位置腐化了)**

```java
int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
Queue<int[]> queue = new LinkedList<>();
int time = 0;
int fresh=0;
for (int i = 0; i < grid.length; i++) {
    for (int j = 0; j < grid[0].length; j++) {
        if (grid[i][j] == 2) {
            queue.add(new int[]{i, j});
        } else if (grid[i][j] == 1) {
            fresh++;
        }
    }
}public int orangesRotting(int[][] grid) {
    int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    Queue<int[]> queue = new LinkedList<>();
    int time = 0;
    int fresh=0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 2) {
                queue.add(new int[]{i, j});
                //这里为了无新鲜橘子和无腐烂橘子两种特殊用例
            } else if (grid[i][j] == 1) {
                fresh++;
            }
        }
    }
    if(queue.isEmpty() && fresh>0)return -1;
    if(fresh==0)return 0;
    //BFS 广搜
    while (!queue.isEmpty()) {
        int size = queue.size();
        boolean rotten=false;
        //一批全弹出来，进行腐化
        for (int i = 0; i < size; i++) {
            int[] poll = queue.poll();
            int row = poll[0];
            int col = poll[1];
            //考虑到有可能该位置被其他腐化
            if(grid[row][col]==1) {
                //腐化
                grid[row][col] = 2;
                rotten=true;
            }
            //四周扩散
            for (int[] offset : dir) {
                //合法且新鲜
                if (legit(row + offset[0], col + offset[1], grid) 
                    && grid[row + offset[0]][col + offset[1]] == 1) {
                    queue.add(new int[]{row + offset[0],col + offset[1]});
                }
            }
        }
        //有可能队列中都被腐化了，必须该轮有真正腐化的才能time++;
        if(rotten)time++;
    }
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {
                return -1;
            }
        }
    }
    return time;
}
public boolean legit(int row, int col, int[][] grid) {
    return row >= 0 && col >= 0 && row < grid.length && col < grid[0].length;
}
```



#### 课程表

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**拓扑排序问题**

- 入度数组
- 邻接表
- BFS队列广搜，每个节点的下个节点入度--，减为0则放入队列

```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    //key:课程编号 value:依赖该课程的课程集合
    Map<Integer, List<Integer>> map=new HashMap<>();
    //入度数组，即该课程依赖多少前置课程
    int[] inDegrees=new int[numCourses];
    //初始化邻接表与入度数组
    for (int i = 0; i < prerequisites.length; i++) {
        map.putIfAbsent(prerequisites[i][1],new ArrayList<>());
        map.get(prerequisites[i][1]).add(prerequisites[i][0]);
        inDegrees[prerequisites[i][0]]++;
    }
    Queue<Integer>queue=new LinkedList<>();
    //入度为0全部入队
    for (int i = 0; i < inDegrees.length; i++) {
        if(inDegrees[i]==0)queue.add(i);
    }
    int count=0;
    while (!queue.isEmpty()){
        //学习课程
        Integer poll = queue.poll();
        count++;
        //获取该课程的所有后置课程
        List<Integer> nexts = map.getOrDefault(poll,new ArrayList<>());
        for (int i = 0; i < nexts.size(); i++) {
            Integer nextNode = nexts.get(i);
            //后置课程的依赖数-1，如果减到0则放入队列可以学习
            inDegrees[nextNode]--;
            if(inDegrees[nextNode]==0){
                queue.add(nextNode);
            }
        }
    }
    return count==numCourses;
}
```



### 排序法

**H指数**

[274. H 指数](https://leetcode.cn/problems/h-index/)

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且 **至少** 有 `h` 篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

排序后，找下标大于值的元素

```java
public int hIndex(int[] citations) {
    //这里用的是sort，因此需要逆序遍历
        Arrays.sort(citations);
        int count = 1;
        for (int i= citations.length-1; i >= 0; i--) {
            if(citations[i] < count)break;
            count++;
        }
        return count-1;
    }
```

#### 数组的第K个最大元素

[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```







# 三、可能解集问题

## 贪心

### **发饼干**



从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量

<img src="common-image/算法\image-20240827092202640.png" alt="image-20240827092202640" style="zoom:50%;" />

```java
public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);

        int count=0;
        int gIndex=g.length-1;
        //饼干数组指针
        for (int i = s.length-1; i >= 0 && gIndex>=0; i--) {
            //孩子胃口loop
            for (; gIndex >= 0; gIndex--) {
                //最大的饼干分配给胃口最大的，这样饼干的利用价值最大
                if(s[i]>=g[gIndex]){
                    count++;
                    gIndex--;
                    break;
                }
            }
        }
        return count;
    }
```

### 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

- 遍历的过程不断更新最远落点

```java
public boolean canJump(int[] nums) {
    int max=0;
    for (int i = 0; i < nums.length; i++) {
        if(i>max)return false;
        max=Math.max(max, i+nums[i]);
    }
    return true;
}
```







### 跳跃游戏2

[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

返回到达终点的最小跳跃数

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

- 按轮跳跃，遍历一轮内的所有跳点，达到本轮的最终点后，记为一次跳跃
- 遍历一轮内的所有跳点时，不断更新最远落点，达到上轮的最远跳跃位置后，当前可跳最远的落点记为下轮的跳跃的终点

```java
public int jump(int[] nums) {
     int end = 0;
    int jumps = 0;
    int farthest = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        farthest = Math.max(farthest, nums[i] + i);
        if (i == end) {
            jumps++;
            end = farthest;
        }
    }
    return jumps;
}
```



### 划分字母区间

[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

- 片段字母不重复，即当一个片段包含字母x时，这个片段必须延申到字母x的最远下标，来保证包含了所有的字母x
- 用map记录每个字母最远的下标，遍历字符数组时不断更新最远位置，类似于跳跃游戏2

```java
public static List<Integer> partitionLabels(String s) {
    char[] chars = s.toCharArray();
    int[] maxIndexMap = new int[26];
    for (int i = 0; i < chars.length; i++) {
        maxIndexMap[chars[i] - 'a'] = i;
    }
    List<Integer> result = new ArrayList<>();
    int right = 0;
    int prev = -1;
    for (int i = 0; i < chars.length; i++) {
        right = Math.max(maxIndexMap[chars[i] - 'a'], right);
        if (i == right) {
            result.add(right - prev);
            prev = right;
        }
    }
    return result;
}
```









## 回溯

### 模板

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```









### 组合问题

[77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

![image-20240930094340224](common-image/算法\image-20240930094340224.png)

组合问题需要去重，从startIndex开始向后取数

```java
public List<Integer> path=new ArrayList<>();
public List< List<Integer>> result=new ArrayList<>();
public List<List<Integer>> combine(int n, int k) {
    backtracking(n,1,k);
    return result;
}
public void backtracking(int n,int index,int k){
    if(path.size()==k){
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i <= n; i++) {
        path.add(i);
        backtracking(n,i+1,k);
        path.remove(path.size()-1);
    }
}
```



### 全排列

[46. 全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

排列问题，不需要像组合问题 `startIndex` 一样去重，但元素不能重复选择, 用标记数组去重

```java
public List<Integer> path=new ArrayList<>();
public List<List<Integer>> result=new ArrayList<>();
public List<List<Integer>> permute(int[] nums) {
    backtracking(nums,nums.length,new boolean[nums.length]);
    return result;
}
public void backtracking(int[]nums,int k,boolean[] tags){
    if(path.size()==k){
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if(tags[i])continue;
        path.add(nums[i]);
        //标记数组置为true，表示下次循环当前位不可选
        tags[i]=true;
        backtracking(nums,k,tags);
        //恢复
        tags[i]=false;
        path.remove(path.size()-1);
    }
}
```



### 子集

[78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

- 类似于组合问题，只不过子集长度不固定，每层都要收集一次结果s

```java
public List<Integer> path=new ArrayList<>();
public List<List<Integer>> result=new ArrayList<>();
public List<List<Integer>> subsets(int[] nums) {
    backtracking(nums,0);
    return result;
}
public void backtracking(int[]nums,int index){
    result.add(new ArrayList<>(path));
    for (int i = index; i < nums.length; i++) {
        path.add(nums[i]);
        backtracking(nums,i+1);
        path.remove(path.size()-1);
    }
}
```



### 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![image-20241001100729514](common-image/算法\image-20241001100729514.png)

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

- 用 StringBuilder 代替path，存放路径

- 用 String[] 做哈希存字母组合

```java
public StringBuilder stringBuilder=new StringBuilder();
public List<String> result=new ArrayList<>();
public List<String> letterCombinations(String digits) {
    if("".equals(digits))return result;
    String[] map=new String[]{"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    backtracking(map,0,digits);
    return result;
}
public void backtracking(String[] map,int index,String digits){
    if(stringBuilder.length()==digits.length()){
        result.add(stringBuilder.toString());
        return;
    }
    //当前索引字母对应的char集合
    char c = digits.charAt(index);
    char[] chars = map[c-'0'].toCharArray();
    for (int i = 0; i < chars.length; i++) {
        stringBuilder.append(chars[i]);
        backtracking(map,index+1,digits);
        stringBuilder.deleteCharAt(stringBuilder.length()-1);
    }
}
```



### 组合总和

[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

- 组合问题, 可重复选，故index不需要+1

```java
public List<Integer> path = new ArrayList<>();
public List<List<Integer>> result = new ArrayList<>();
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    backtracking(candidates,target,0,0);
    return result;
}
//candidates， target目标和，startIndex组合问题限制前缀，sum总和
public void backtracking(int[] candidates, int target, int startIndex, int sum) {
    if (sum == target) {
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = startIndex; i < candidates.length; i++) {
        sum+=candidates[i];
        //减枝，大于就不用遍历了
        if(sum<=target){
            path.add(candidates[i]);
            backtracking(candidates,target,i,sum);
            path.remove(path.size()-1);
        }
        sum-=candidates[i];
    }
}
```





### 括号生成



数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

![image-20241002103721473](common-images\image-20241002103721473.png)

- 通过 usableOpen , needClose 记录 `可用的开括号数` 和 `需要关闭的开括号数`
- 每次选择拼接` '('` or` ')'`

```java
public List<String> result=new ArrayList<>();
public StringBuilder path=new StringBuilder();
public List<String> generateParenthesis(int n) {
    dfs(n,0);
    return result;
}
public void dfs(int usableOpen,int needClose){
    if(usableOpen==0 && needClose==0){
        result.add(path.toString());
        return;
    }
    //仍有可用 (
    if(usableOpen>0){
        //添加'('
        path.append("(");
        dfs(usableOpen-1,needClose+1);
        path.deleteCharAt(path.length()-1);
    }
    //仍有需要close的
    if(needClose>0){
        //添加')'
        path.append(")");
        dfs(usableOpen,needClose-1);
        path.deleteCharAt(path.length()-1);
    }
}
```



### 分割回文串



需要掌握: 字符串-验证回文串

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 回文串 。返回 `s` 所有可能的分割方案。

- 回溯+动态规划预处理

![image-20241006150459121](common-image/算法\image-20241006150459121.png)

动态规划预处理

- `dp[i][j] `: i-j 区间是否为回文串
- 状态转移方程:  `dp[i][j]=s.charAt(i)==s.charAt(j) && dp[i-1][j+1];`  i，j位置字符相等，且内部包含着回文串

```java
List<String> path=new ArrayList<>();
List<List<String>> result=new ArrayList<>();
public List<List<String>> partition(String s) {
    boolean[][]dp=new boolean[s.length()][s.length()];
    dp[0][0]=true;
    for (int i = 1; i < dp.length; i++) {
        for (int j = 0; j <= i; j++) {
            dp[i][j]=s.charAt(i)==s.charAt(j) && dp[i-1][j+1];
        }
    }
    backtracking(0,s,dp);
    return result;
}
public void backtracking(int j,String s,boolean[][]dp){
    if(j==s.length()){
        result.add(new ArrayList<>(path));
        return;
    }
    char[] chars = s.toCharArray();
    for (int i = j; i < chars.length; i++) {
        //if(isPalindrome(j,i,s)){
        if(dp[i][j]){
            path.add(s.substring(j,i+1));
            backtracking(i+1,s,dp);
            path.remove(path.size()-1);
        }
    }
}
public boolean isPalindrome(int j,int i,String s) {
    char[] chars = s.toCharArray();
    int left = j;
    int right = i;
    while (left <= right) {
        if (chars[left] != chars[right]) return false;
        left++;
        right--;
    }
    return true;
}
```



### n皇后

[51. N 皇后](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

```java
private List<Integer> path = new ArrayList<>();
    private List<List<String>> res = new ArrayList<>();
    private StringBuffer buffer = new StringBuffer();

    public List<List<String>> solveNQueens(int n) {
        for (int i = 0; i < n; i++) {
            buffer.append(".");
        }
        backtrack(new boolean[n], n, 0);
        return res;
    }

    public void backtrack(boolean[] tag, int n, int row) {
        if (row == n ) {
            List<String> temp = new ArrayList<>();
            for (Integer i : path) {
                temp.add(buildString(i));
            }
            res.add(temp);
            return;
        }
        for (int col = 0; col < n; col++) {
            boolean atSlash = false;
            for (int i = 0; i < path.size(); i++) {
                Integer j = path.get(i);
                if (row + col == i + j || row - col == i - j) {
                    atSlash = true;
                    break;
                }
            }
            if (tag[col] || atSlash) continue;
            path.add(col);
            tag[col] = true;
            backtrack(tag, n, row + 1);
            path.remove(path.size() - 1);
            tag[col] = false;
        }
    }
    
    public String buildString(int i){
        buffer.setCharAt(i, 'Q');
        String str = buffer.toString();
        buffer.setCharAt(i, '.');
        return str;
    }
```



## 动态规划

### 递推

#### 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

- dp[i]=dp[i-1]+dp[i-2]

```java
public int climbStairs(int n) {
    int[]dp=new int[n+1];
    dp[0]=1;
    dp[1]=1;
    for (int i = 2; i < dp.length; i++) {
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
}
```



#### 杨辉三角

[118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)



**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```



```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> result=new ArrayList<>();
    int[]dp=new int[numRows];
    //行数
    for (int i = 0; i < numRows; i++) {
        result.add(new ArrayList<>());
        //槽位
        for (int j = i; j >=0; j--) {
            if(j==0 || j==i) {
                dp[j]=1;
            }else {
                dp[j]+=dp[j-1];
            }
            result.get(i).add(dp[j]);
        }
    }
    return result;
}
```



### 背包问题

#### 基础

- 定义dp数组
- 确定状态转移 `dp[j] = Math.max(dp[j], dp[j - weight[i]]+value[i]);`
- 边界条件与初始化

#### 01背包

[46. 携带研究材料（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1046)

```java
import java.util.Scanner;

public class Main  {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int size = scanner.nextInt();
        int[] itemSize = new int[n];
        int[] itemValue = new int[n];

        for (int i = 0; i < n; ++i) {
            itemSize[i] = scanner.nextInt();
        }
        for (int j = 0; j < n; ++j) {
            itemValue[j] = scanner.nextInt();
        }
        maxValue(n, size, itemSize, itemValue);
    }

    public static void maxValue(int n, int size, int[] itemSize, int[] itemValue) {
       实现
    }


}
```

二维数组

```java
public static void maxValue(int n, int size, int[] itemSize, int[] itemValue) {
    int[][] dp = new int[n][size + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 1; j < size + 1; j++) {
            if (i == 0) {
                dp[i][j] = j >= itemSize[0] ? itemValue[i] : 0;
            } else {
                dp[i][j] = j - itemSize[i] >= 0 ? Math.max(dp[i - 1][j], dp[i - 1][j - itemSize[i]] + itemValue[i]) : dp[i - 1][j];
            }
        }
    }
    System.out.println(dp[n - 1][size]);
}
```

滚动数组

```java
public static void maxValue2(int n, int size, int[] itemSize, int[] itemValue) {
    int[]dp = new int[size + 1];
    for (int i = 0; i < n; i++) {
        for (int j = size; j >= 0 && j > itemSize[i]; j--) {
            if(i == 0) {
                dp[j] = itemValue[i];
            }else {
                dp[j] = Math.max(dp[j], dp[j - itemSize[i]]+itemValue[i]);
            }
        }
    }
    System.out.println(dp[size]);
}
```







#### 打家劫舍



你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```



```java
public int rob(int[] nums) {
    if(nums.length<2)return nums[0];
    int[]dp=new int[nums.length];
    dp[0]=nums[0];
    dp[1]=Math.max(nums[0],nums[1]);
    for (int i = 2; i < dp.length; i++) {
        dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
    }
    return dp[nums.length-1];
}
```





#### 完全平方数

[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

- 初始化背包时， 初始`(int)Math.sqrt(n)`个元素即可

- 完全背包问题，背包 :` [1,4,9,16,......]` ， 求总和相等时元素最少的情况 - > **一维dp数组向后更新**
- 状态转移 `dp[j] = Math.min(dp[j], dp[j - nums[i]] + 1);`

```java
public int numSquares(int n) {
    //初始化背包
    int sqrt=(int)Math.sqrt(n);
    int[] nums = new int[sqrt + 1];
    for (int i = 0; i < nums.length; i++) {
        nums[i]=i*i;
    }
    int[] dp = new int[n + 1];
    Arrays.fill(dp,Integer.MAX_VALUE);
    dp[0]=0;
    //物品
    for (int i = 1; i<nums.length; i++) {
        //容量
        for (int j = nums[i]; j <= n; j++) {
            dp[j] = Math.min(dp[j], dp[j - nums[i]] + 1);
        }
    }
    return dp[n];
}
```

如果取得是两个子问题的较小者，注意数组默认的0会干扰比较。可以取 `Arrays.fill(dp,Integer.MAX_VALUE) (有可能溢出)`or `Arrays.fill(dp, amount + 1)(不会溢出)` 来作为默认

#### 零钱兑换

[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```



```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    //背包
    for (int i = 0; i < coins.length; i++) {
        //容量
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
    }
    //如果未更新，说明无法凑成
    return dp[amount] > amount ? -1 : dp[amount];
}
```



#### 分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

- 01背包，选择元素使和为 `sum/2`

```java
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if(sum%2!=0)return false;
    int target=sum/2;
    boolean[]dp=new boolean[target+1];
    //第一次放入的更新需要 dp[0]=true
    dp[0]=true;
    for (int i = 0; i < nums.length; i++) {
        //01背包，一维数组倒序遍历
        for (int j = target; j >=nums[i]; j--) {
            dp[j]=dp[j] || dp[j-nums[i]];
        }
    }
    return dp[target];
}
```

### 单串问题

#### 单词拆分

[139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```



![image-20241005112540685](common-image/算法\image-20241005112540685.png)

```java
Set<String> set = new HashSet<>(wordDict);
boolean[] dp = new boolean[s.length() + 1];
dp[0] = true;
for (int i = 1; i < dp.length; i++) {
    for (int j = 0; j < i; j++) {
        if (dp[j] && set.contains(s.substring(j, i))) {
            dp[i] = true;
            break;
        }
    }
}
return dp[s.length()];
```



#### 最长递增子序列

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

- 因为要比较序列尾的大小，所以dp表示**以i结尾的子序列长度**

```java
public int lengthOfLIS(int[] nums) {
    int[]dp=new int[nums.length];
    int max=1;
    //每个元素自身为长度1的序列
    Arrays.fill(dp,1);
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j < i; j++) {
            if(nums[i]>nums[j]){
                dp[i]=Math.max(dp[i],dp[j]+1);
            }
        }
        max=Math.max(dp[i],max);
    }
    return max;
}
```



#### 乘积最大子数组

[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 

子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

```java
public int maxProduct2(int[] nums) {
    int[][]dp=new int[nums.length][2];
    //最大值
    dp[0][0]=nums[0];
    //最小值
    dp[0][1]=nums[0];
    int max=dp[0][0];
    for (int i = 1; i < dp.length; i++) {
        //最大值 如果i是正数，则取 max(前一个最大 * nums[i], nums[i]) 负的，则取 max(prevMin * nums[i], nums[i])
        dp[i][0]= nums[i]>0?Math.max(nums[i],dp[i-1][0]*nums[i]):Math.max(nums[i],dp[i-1][1]*nums[i]);
        //最小值
        dp[i][1]=nums[i]>0?Math.min(nums[i],dp[i-1][1]*nums[i]):Math.min(nums[i],dp[i-1][0]*nums[i]);
        max=Math.max(max,dp[i][0]);
    }
    return max;
}
```

单串

#### 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**

是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

- dp[i] : 以第i个元素结尾的子数组最大和
- 转移: dp[i]= max { `dp[i-1] + nums[i] ,nums[i]` };  即 （`前面子数组和当前元素拼接 or 以当前数组为始单开一个新的子数组` )

```java
public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0]=nums[0];
    int max=nums[0];
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
        max=Math.max(max,dp[i]);
    }
    return max;
}
```



#### 最长有效括号



给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```



法一: dp

![image-20241005155603741](common-image/算法\image-20241005155603741.png)

```java
public int longestValidParentheses(String s) {
    if(s.length()==0)return 0;
    int[]dp=new int[s.length()];
    char[] chars = s.toCharArray();
    int max=0;
    dp[0]=0;
    for (int i = 1; i < dp.length; i++) {
        if(chars[i]=='('){
            dp[i]=0;
        }//括号能匹配上
        else if(chars[i]==')'&& i-dp[i-1]-1>=0 && chars[i-dp[i-1]-1]=='('){
            //外部连在一起，外部下标可能为-1
            if(i-dp[i-1]-2>=0){
                //基础2 + 内部dp[i-1] +外部dp[i-dp[i-1]-1-1]
                dp[i]=2+dp[i-1]+dp[i-dp[i-1]-2];
            }else{
                //基础2 + 内部dp[i-1]
                dp[i]=2+dp[i-1];
            }
        }
        max=Math.max(dp[i],max);
    }
    return max;
}
```



#### 最长回文子串-二维

[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的 回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

![image-20250325214007346](common-image/算法/image-20250325214007346.png)

```java
public String longestPalindrome(String s) {
    int[][] dp = new int[s.length()][s.length()];
    char[] chars = s.toCharArray();
    dp[0][0] = 1;
    int max = 1;
    String maxStr = s.substring(0,1);
    for (int i = 1; i < dp.length; i++) {
        for (int j = 0; j <= i && dp[i][j] == 0; j++) {
            //相邻或相等，包含 aa 或者 a 这两种情况
            if(i-j<2 && chars[i]==chars[j]){
                dp[i][j] = i-j+1;
                //不相邻，判断i与j中间是否是回文子串
            } else if (chars[i] == chars[j] && dp[i - 1][j + 1] > 0) {
                dp[i][j] = dp[i - 1][j + 1] + 2;
            }
            if(dp[i][j]>max){
                max =dp[i][j];
                maxStr=s.substring(j,i+1);
            }
            System.out.println("i,j :"+i+","+j+"value:"+dp[i][j]);
        }
    }
    return maxStr;
}
```





### 图状dp

#### 不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```



```java
public int uniquePaths(int m, int n) {
    int[][]dp=new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if(i==0 || j==0) {
                dp[i][j]=1;
            }else {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
```





#### 最小路径和

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```



```java
public int minPathSum(int[][] grid) {
    int[][]dp=new int[grid.length+1][grid[0].length+1];
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j < dp[0].length; j++) {
            if(i==0 && j==0){
                dp[0][0]=grid[0][0];
            }else if(i==0){
                dp[i][j]=dp[i][j-1]+grid[i][j];
            }else if(j==0){
                dp[i][j]=dp[i-1][j]+grid[i][j];
            }else {
                dp[i][j]= Math.min(dp[i][j-1],dp[i-1][j])+grid[i][j];
            }
            System.out.println("i,j:"+i+","+j+" dp:"+dp[i][j]);
        }
    }
    return dp[grid.length-1][grid[0].length-1];
}
```





### 双串问题

#### 最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

![image-20241007120836428](common-image/算法\image-20241007120836428.png)





用`new int[text1.length()+1][text2.length()+1]` 来避免 `i==0 和 j==0` 的特殊情况

```java
public int longestCommonSubsequence(String text1, String text2) {
    int[][]dp=new int[text1.length()+1][text2.length()+1];
    for (int i = 1; i <= text1.length(); i++) {
        for (int j = 1; j <= text2.length(); j++) {
            dp[i][j]=text1.charAt(i-1)==text2.charAt(j-1)?dp[i-1][j-1]+1:Math.max(dp[i-1][j],dp[i][j-1]);
        }
    }
    return dp[text1.length()][text2.length()];
}
```



#### 编辑距离

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

状态转移过程

![image-20241011111853228](common-image/算法\image-20241011111853228.png)

![image-20241011111950315](common-image/算法\image-20241011111950315.png)

```java
public int minDistance(String word1, String word2) {
    char[] charsA = word1.toCharArray();
    char[] charsB = word2.toCharArray();
    int [][] dp=new int[word1.length()+1][word2.length()+1];
    for (int i = 0; i < dp.length; i++) {
        dp[i][0]=i;
    }
    for (int j = 0; j < dp[0].length; j++) {
        dp[0][j]=j;
    }
    for (int i = 1; i < dp.length; i++) {
        for (int j = 1; j < dp[0].length; j++) {
            dp[i][j]=charsA[i-1]==charsB[j-1]
                ?dp[i-1][j-1]: Math.min(dp[i-1][j], Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
        }
    }
    return dp[word1.length()][word2.length()];
}
```

#### 最长重复子数组

i，j 下标i为结尾的子数组

` dp[i][j]=nums1[i]==nums2[j]?dp[i-1][j-1]+1:0;`

```java
public int findLength(int[] nums1, int[] nums2) {
  int[][]dp=new int[nums1.length][nums2.length];
   int max=0;
   for (int i = 0; i < nums1.length; i++) {
       for (int j = 0; j < nums2.length; j++) {
           if(i==0||j==0){
               dp[i][j]=nums1[i]==nums2[j]?1:0;
           }else {
               dp[i][j]=nums1[i]==nums2[j]?dp[i-1][j-1]+1:0;
           }
           if(dp[i][j]>max)max=dp[i][j];
       }
   }
   return max;
}
```

### other









## 滑动窗口

### 无重复字符的最长子串

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```java
public int lengthOfLongestSubstring(String s) {
    char[] chars = s.toCharArray();
    int r=0;
    int l=0;
    Set<Character> set=new HashSet<>();
    int max=0;
    while(l<=r && r < chars.length){
        char c=chars[r];
        while(set.contains(chars[r])){
            set.remove(chars[l]);
            l++;
        }
        //到这已经无重复了
        set.add(c);
        max=Math.max(max,r-l+1);
        r++;
    }
    return max;
}
```



### 字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)











# 双指针



#### 比较版本号

给你两个 **版本号字符串** `version1` 和 `version2` ，请你比较它们。版本号由被点 `'.'` 分开的修订号组成。**修订号的值** 是它 **转换为整数** 并忽略前导零。

比较版本号时，请按 **从左到右的顺序** 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 `0`。

返回规则如下：

-  如果 `version1 < version2` 返回 `-1`，
- 如果 `version1 > version2` 返回 `1`，
- 除此之外返回 `0`。

示例

```
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都代表相同的整数 "1"。
```



```java
public int compareVersion(String version1, String version2) {
    char[] charsV1 = version1.toCharArray();
    char[] charsV2 = version2.toCharArray();
    int left=0;
    int right=0;
    //考虑到 "1.0.1"比较"1" 这种用例，需要两个指针都越界才结束，单个指针越界后count为0仍可以比较
    while (left<version1.length() || right<version2.length()){
        int leftCount=0;
        //上一位 * 10 +当前位
        while (left<version1.length() && charsV1[left]!='.'){
            leftCount*=10;
            leftCount+=charsV1[left]-'0';
            left++;
        }
        int rightCount=0;
        while (right<version2.length() && charsV2[right]!='.'){
            rightCount*=10;
            rightCount+=charsV2[right]-'0';
            right++;
        }
        if(leftCount!=rightCount) {
            return leftCount-rightCount>0?1:-1;
        }
        //左右同时跳过点号
        left++;
        right++;
    }
    return 0;
}
```



# 字符串 

### 回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

- 双指针，如果`left!=right`，则不是回文串

```java
public boolean isPalindrome(String s) {
    char[] chars = s.toLowerCase().toCharArray();
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < chars.length; i++) {
        if (('a' <= chars[i] && chars[i] <= 'z') || ('0' <= chars[i] && chars[i] <= '9')) {
            builder.append(chars[i]);
        }
    }
    int left = 0;
    int right = builder.length() - 1;
    while (left <= right) {
        if (builder.charAt(left) != builder.charAt(right)) return false;
        left++;
        right--;
    }
    return true;
}
```

### 同构字符串

[205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```java
public boolean isIsomorphic(String s, String t) {
        return verify(s, t) && verify(t, s);
    }

    public boolean verify(String s, String t) {
        char[] sMap = new char[128];
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        for (int i = 0; i < sChars.length; i++) {
            if(sMap[sChars[i]] == 0) {
                sMap[sChars[i]] = t.charAt(i);
            }else if(sMap[sChars[i]] != tChars[i]){
                return false;
            }
        }
        return true;
    }
```



### 单词规律

[290. 单词规律](https://leetcode.cn/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

解法同 `同构字符串`

















# 技巧-hot

只出现一次的数字

[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

- 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
- 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
- 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。

异或运算有个重要的性质，两个相同数字异或为 0 ，即对于任意整数 a 有 a⊕a=0 。因此，若将 nums 中所有数字执行异或运算，留下的结果则为 出现一次的数字 x ，即：a⊕a⊕b⊕b⊕...⊕x = 0⊕0⊕...⊕x =  x

```java
public int singleNumber(int[] nums) {
    int single = 0;
    for (int num : nums) {
        single ^= num;
    }
    return single;
}
```







# other

### 多数元素

[169. 多数元素](https://leetcode.cn/problems/majority-element/)

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

#### 哈希表

统计次数，每次+1时判断是否 > nums.length

#### 分治

如果在`[i,j]` 某个数为众数，那必然该数为左区间众数或右区间众数

如果左右区间众数不等，则需要遍历完整区间，统计次数，比较两个众数谁次数多

如果相等，则完整区间众数即为该数

```java
public int majorityElementPartition(int[] nums) {
        return partition(nums, 0, nums.length - 1);
    }

    public int partition(int[] nums,int i,int j) {
        if(i==j) return nums[i];
        int mid = (i + j) / 2;
        int left = partition(nums, i, mid);
        int right = partition(nums, mid+1, j);
        if(left==right){
            return left;
        }else {
            int leftCount = countInRange(nums, i,j, left);
            int rightCount = countInRange(nums, i,j, right);
            return leftCount > rightCount ? left : right;
        }
    }

    public int countInRange(int[] nums,int i,int j,int value) {
        int count = 0;
        for (int k = i; k <=j; k++) {
            if(nums[k]==value){
                count++;
            }
        }
        return count;
    }
```



#### Moore投票

思想

Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。

如果数组为空，则数组中不存在主要元素；

如果数组中剩下的元素都相等，则数组中剩下的元素可能为主要元素。（可能的原因是，如果是这样的一个数组[1,2,3]，那么剩下的元素是3，但是3并不是数量超过一半的元素。）

!`相当于两个军队战斗，1v1抵消，剩下的兵一定是人数较多那个军队的`

具体实现：遇到

```java
public int majorityElementMoore(int[] nums) {
        Integer candidate = nums[0];
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            if(count == 0){
                candidate = nums[i];
                count = 1;
            }else if(nums[i] == candidate){
                count++;
            }else {
                count--;
            }
        }
        return candidate;
    }
```

### 前后缀

#### 分发糖果

[135. 分发糖果](https://leetcode.cn/problems/candy/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。



```java
public int candy(int[] ratings) {
    int n = ratings.length;
    if (n == 0) {
        return 0;
    }
    int[] candies = new int[n];
    Arrays.fill(candies, 1);
    // 从左到右遍历
    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    // 从右到左遍历
    for (int i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
    }
    // 计算总糖果数
    int sum = 0;
    for (int candy : candies) {
        sum += candy;
    }
    return sum;
}
```

#### 除自身以为数组的乘积

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。



```java
public int[] productExceptSelf(int[] nums) {
    int left=0,right=nums.length-1;
    int lc=1,rc=1;
    int[] ans=new int[nums.length];
    Arrays.fill(ans,1);
    while (left<=nums.length-1 && right>=0){
        ans[left]*=lc;
        ans[right]*=rc;
        lc*=nums[left++];
        rc*=nums[right--];
    }
    return ans;
}
```





